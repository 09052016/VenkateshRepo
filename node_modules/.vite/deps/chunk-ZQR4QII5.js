// node_modules/@realpage/rum-react-library/dist/index-9713ef3a.js
var l = globalThis || void 0 || self;

// node_modules/@realpage/rum-react-library/dist/index-e5d51460.js
var fr = {};
var O = {};
O.byteLength = br;
O.toByteArray = Dr;
O.fromByteArray = Or;
var _ = [];
var T = [];
var Nr = typeof Uint8Array < "u" ? Uint8Array : Array;
var X = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (D2 = 0, Mr = X.length; D2 < Mr; ++D2)
  _[D2] = X[D2], T[X.charCodeAt(D2)] = D2;
var D2;
var Mr;
T["-".charCodeAt(0)] = 62;
T["_".charCodeAt(0)] = 63;
function cr(p) {
  var c = p.length;
  if (c % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var a2 = p.indexOf("=");
  a2 === -1 && (a2 = c);
  var x = a2 === c ? 0 : 4 - a2 % 4;
  return [a2, x];
}
function br(p) {
  var c = cr(p), a2 = c[0], x = c[1];
  return (a2 + x) * 3 / 4 - x;
}
function kr(p, c, a2) {
  return (c + a2) * 3 / 4 - a2;
}
function Dr(p) {
  var c, a2 = cr(p), x = a2[0], w = a2[1], f = new Nr(kr(p, x, w)), l2 = 0, m = w > 0 ? x - 4 : x, B;
  for (B = 0; B < m; B += 4)
    c = T[p.charCodeAt(B)] << 18 | T[p.charCodeAt(B + 1)] << 12 | T[p.charCodeAt(B + 2)] << 6 | T[p.charCodeAt(B + 3)], f[l2++] = c >> 16 & 255, f[l2++] = c >> 8 & 255, f[l2++] = c & 255;
  return w === 2 && (c = T[p.charCodeAt(B)] << 2 | T[p.charCodeAt(B + 1)] >> 4, f[l2++] = c & 255), w === 1 && (c = T[p.charCodeAt(B)] << 10 | T[p.charCodeAt(B + 1)] << 4 | T[p.charCodeAt(B + 2)] >> 2, f[l2++] = c >> 8 & 255, f[l2++] = c & 255), f;
}
function $r(p) {
  return _[p >> 18 & 63] + _[p >> 12 & 63] + _[p >> 6 & 63] + _[p & 63];
}
function Pr(p, c, a2) {
  for (var x, w = [], f = c; f < a2; f += 3)
    x = (p[f] << 16 & 16711680) + (p[f + 1] << 8 & 65280) + (p[f + 2] & 255), w.push($r(x));
  return w.join("");
}
function Or(p) {
  for (var c, a2 = p.length, x = a2 % 3, w = [], f = 16383, l2 = 0, m = a2 - x; l2 < m; l2 += f)
    w.push(Pr(p, l2, l2 + f > m ? m : l2 + f));
  return x === 1 ? (c = p[a2 - 1], w.push(
    _[c >> 2] + _[c << 4 & 63] + "=="
  )) : x === 2 && (c = (p[a2 - 2] << 8) + p[a2 - 1], w.push(
    _[c >> 10] + _[c >> 4 & 63] + _[c << 2 & 63] + "="
  )), w.join("");
}
var J = {};
J.read = function(p, c, a2, x, w) {
  var f, l2, m = w * 8 - x - 1, B = (1 << m) - 1, F = B >> 1, o = -7, A2 = a2 ? w - 1 : 0, S = a2 ? -1 : 1, R = p[c + A2];
  for (A2 += S, f = R & (1 << -o) - 1, R >>= -o, o += m; o > 0; f = f * 256 + p[c + A2], A2 += S, o -= 8)
    ;
  for (l2 = f & (1 << -o) - 1, f >>= -o, o += x; o > 0; l2 = l2 * 256 + p[c + A2], A2 += S, o -= 8)
    ;
  if (f === 0)
    f = 1 - F;
  else {
    if (f === B)
      return l2 ? NaN : (R ? -1 : 1) * (1 / 0);
    l2 = l2 + Math.pow(2, x), f = f - F;
  }
  return (R ? -1 : 1) * l2 * Math.pow(2, f - x);
};
J.write = function(p, c, a2, x, w, f) {
  var l2, m, B, F = f * 8 - w - 1, o = (1 << F) - 1, A2 = o >> 1, S = w === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, R = x ? 0 : f - 1, N2 = x ? 1 : -1, G2 = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
  for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (m = isNaN(c) ? 1 : 0, l2 = o) : (l2 = Math.floor(Math.log(c) / Math.LN2), c * (B = Math.pow(2, -l2)) < 1 && (l2--, B *= 2), l2 + A2 >= 1 ? c += S / B : c += S * Math.pow(2, 1 - A2), c * B >= 2 && (l2++, B /= 2), l2 + A2 >= o ? (m = 0, l2 = o) : l2 + A2 >= 1 ? (m = (c * B - 1) * Math.pow(2, w), l2 = l2 + A2) : (m = c * Math.pow(2, A2 - 1) * Math.pow(2, w), l2 = 0)); w >= 8; p[a2 + R] = m & 255, R += N2, m /= 256, w -= 8)
    ;
  for (l2 = l2 << w | m, F += w; F > 0; p[a2 + R] = l2 & 255, R += N2, l2 /= 256, F -= 8)
    ;
  p[a2 + R - N2] |= G2 * 128;
};
(function(p) {
  const c = O, a2 = J, x = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  p.Buffer = o, p.SlowBuffer = sr, p.INSPECT_MAX_BYTES = 50;
  const w = 2147483647;
  p.kMaxLength = w;
  const { Uint8Array: f, ArrayBuffer: l2, SharedArrayBuffer: m } = globalThis;
  o.TYPED_ARRAY_SUPPORT = B(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function B() {
    try {
      const i = new f(1), r = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r, f.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (o.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(o.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (o.isBuffer(this))
        return this.byteOffset;
    }
  });
  function F(i) {
    if (i > w)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
    const r = new f(i);
    return Object.setPrototypeOf(r, o.prototype), r;
  }
  function o(i, r, t) {
    if (typeof i == "number") {
      if (typeof r == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return N2(i);
    }
    return A2(i, r, t);
  }
  o.poolSize = 8192;
  function A2(i, r, t) {
    if (typeof i == "string")
      return G2(i, r);
    if (l2.isView(i))
      return pr(i);
    if (i == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i
      );
    if (C(i, l2) || i && C(i.buffer, l2) || typeof m < "u" && (C(i, m) || i && C(i.buffer, m)))
      return W2(i, r, t);
    if (typeof i == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const n = i.valueOf && i.valueOf();
    if (n != null && n !== i)
      return o.from(n, r, t);
    const e = lr(i);
    if (e)
      return e;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
      return o.from(i[Symbol.toPrimitive]("string"), r, t);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i
    );
  }
  o.from = function(i, r, t) {
    return A2(i, r, t);
  }, Object.setPrototypeOf(o.prototype, f.prototype), Object.setPrototypeOf(o, f);
  function S(i) {
    if (typeof i != "number")
      throw new TypeError('"size" argument must be of type number');
    if (i < 0)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
  }
  function R(i, r, t) {
    return S(i), i <= 0 ? F(i) : r !== void 0 ? typeof t == "string" ? F(i).fill(r, t) : F(i).fill(r) : F(i);
  }
  o.alloc = function(i, r, t) {
    return R(i, r, t);
  };
  function N2(i) {
    return S(i), F(i < 0 ? 0 : j2(i) | 0);
  }
  o.allocUnsafe = function(i) {
    return N2(i);
  }, o.allocUnsafeSlow = function(i) {
    return N2(i);
  };
  function G2(i, r) {
    if ((typeof r != "string" || r === "") && (r = "utf8"), !o.isEncoding(r))
      throw new TypeError("Unknown encoding: " + r);
    const t = z2(i, r) | 0;
    let n = F(t);
    const e = n.write(i, r);
    return e !== t && (n = n.slice(0, e)), n;
  }
  function Y2(i) {
    const r = i.length < 0 ? 0 : j2(i.length) | 0, t = F(r);
    for (let n = 0; n < r; n += 1)
      t[n] = i[n] & 255;
    return t;
  }
  function pr(i) {
    if (C(i, f)) {
      const r = new f(i);
      return W2(r.buffer, r.byteOffset, r.byteLength);
    }
    return Y2(i);
  }
  function W2(i, r, t) {
    if (r < 0 || i.byteLength < r)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (i.byteLength < r + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let n;
    return r === void 0 && t === void 0 ? n = new f(i) : t === void 0 ? n = new f(i, r) : n = new f(i, r, t), Object.setPrototypeOf(n, o.prototype), n;
  }
  function lr(i) {
    if (o.isBuffer(i)) {
      const r = j2(i.length) | 0, t = F(r);
      return t.length === 0 || i.copy(t, 0, 0, r), t;
    }
    if (i.length !== void 0)
      return typeof i.length != "number" || V2(i.length) ? F(0) : Y2(i);
    if (i.type === "Buffer" && Array.isArray(i.data))
      return Y2(i.data);
  }
  function j2(i) {
    if (i >= w)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + w.toString(16) + " bytes");
    return i | 0;
  }
  function sr(i) {
    return +i != i && (i = 0), o.alloc(+i);
  }
  o.isBuffer = function(r) {
    return r != null && r._isBuffer === true && r !== o.prototype;
  }, o.compare = function(r, t) {
    if (C(r, f) && (r = o.from(r, r.offset, r.byteLength)), C(t, f) && (t = o.from(t, t.offset, t.byteLength)), !o.isBuffer(r) || !o.isBuffer(t))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (r === t)
      return 0;
    let n = r.length, e = t.length;
    for (let u = 0, h2 = Math.min(n, e); u < h2; ++u)
      if (r[u] !== t[u]) {
        n = r[u], e = t[u];
        break;
      }
    return n < e ? -1 : e < n ? 1 : 0;
  }, o.isEncoding = function(r) {
    switch (String(r).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, o.concat = function(r, t) {
    if (!Array.isArray(r))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r.length === 0)
      return o.alloc(0);
    let n;
    if (t === void 0)
      for (t = 0, n = 0; n < r.length; ++n)
        t += r[n].length;
    const e = o.allocUnsafe(t);
    let u = 0;
    for (n = 0; n < r.length; ++n) {
      let h2 = r[n];
      if (C(h2, f))
        u + h2.length > e.length ? (o.isBuffer(h2) || (h2 = o.from(h2)), h2.copy(e, u)) : f.prototype.set.call(
          e,
          h2,
          u
        );
      else if (o.isBuffer(h2))
        h2.copy(e, u);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      u += h2.length;
    }
    return e;
  };
  function z2(i, r) {
    if (o.isBuffer(i))
      return i.length;
    if (l2.isView(i) || C(i, l2))
      return i.byteLength;
    if (typeof i != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i
      );
    const t = i.length, n = arguments.length > 2 && arguments[2] === true;
    if (!n && t === 0)
      return 0;
    let e = false;
    for (; ; )
      switch (r) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return H2(i).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return hr(i).length;
        default:
          if (e)
            return n ? -1 : H2(i).length;
          r = ("" + r).toLowerCase(), e = true;
      }
  }
  o.byteLength = z2;
  function ar(i, r, t) {
    let n = false;
    if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
      return "";
    for (i || (i = "utf8"); ; )
      switch (i) {
        case "hex":
          return Fr(this, r, t);
        case "utf8":
        case "utf-8":
          return Q2(this, r, t);
        case "ascii":
          return mr(this, r, t);
        case "latin1":
        case "binary":
          return Ir(this, r, t);
        case "base64":
          return dr(this, r, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ar(this, r, t);
        default:
          if (n)
            throw new TypeError("Unknown encoding: " + i);
          i = (i + "").toLowerCase(), n = true;
      }
  }
  o.prototype._isBuffer = true;
  function M2(i, r, t) {
    const n = i[r];
    i[r] = i[t], i[t] = n;
  }
  o.prototype.swap16 = function() {
    const r = this.length;
    if (r % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < r; t += 2)
      M2(this, t, t + 1);
    return this;
  }, o.prototype.swap32 = function() {
    const r = this.length;
    if (r % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < r; t += 4)
      M2(this, t, t + 3), M2(this, t + 1, t + 2);
    return this;
  }, o.prototype.swap64 = function() {
    const r = this.length;
    if (r % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < r; t += 8)
      M2(this, t, t + 7), M2(this, t + 1, t + 6), M2(this, t + 2, t + 5), M2(this, t + 3, t + 4);
    return this;
  }, o.prototype.toString = function() {
    const r = this.length;
    return r === 0 ? "" : arguments.length === 0 ? Q2(this, 0, r) : ar.apply(this, arguments);
  }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(r) {
    if (!o.isBuffer(r))
      throw new TypeError("Argument must be a Buffer");
    return this === r ? true : o.compare(this, r) === 0;
  }, o.prototype.inspect = function() {
    let r = "";
    const t = p.INSPECT_MAX_BYTES;
    return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
  }, x && (o.prototype[x] = o.prototype.inspect), o.prototype.compare = function(r, t, n, e, u) {
    if (C(r, f) && (r = o.from(r, r.offset, r.byteLength)), !o.isBuffer(r))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r
      );
    if (t === void 0 && (t = 0), n === void 0 && (n = r ? r.length : 0), e === void 0 && (e = 0), u === void 0 && (u = this.length), t < 0 || n > r.length || e < 0 || u > this.length)
      throw new RangeError("out of range index");
    if (e >= u && t >= n)
      return 0;
    if (e >= u)
      return -1;
    if (t >= n)
      return 1;
    if (t >>>= 0, n >>>= 0, e >>>= 0, u >>>= 0, this === r)
      return 0;
    let h2 = u - e, s = n - t;
    const d = Math.min(h2, s), E2 = this.slice(e, u), g2 = r.slice(t, n);
    for (let y = 0; y < d; ++y)
      if (E2[y] !== g2[y]) {
        h2 = E2[y], s = g2[y];
        break;
      }
    return h2 < s ? -1 : s < h2 ? 1 : 0;
  };
  function K2(i, r, t, n, e) {
    if (i.length === 0)
      return -1;
    if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, V2(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
      if (e)
        return -1;
      t = i.length - 1;
    } else if (t < 0)
      if (e)
        t = 0;
      else
        return -1;
    if (typeof r == "string" && (r = o.from(r, n)), o.isBuffer(r))
      return r.length === 0 ? -1 : Z2(i, r, t, n, e);
    if (typeof r == "number")
      return r = r & 255, typeof f.prototype.indexOf == "function" ? e ? f.prototype.indexOf.call(i, r, t) : f.prototype.lastIndexOf.call(i, r, t) : Z2(i, [r], t, n, e);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Z2(i, r, t, n, e) {
    let u = 1, h2 = i.length, s = r.length;
    if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
      if (i.length < 2 || r.length < 2)
        return -1;
      u = 2, h2 /= 2, s /= 2, t /= 2;
    }
    function d(g2, y) {
      return u === 1 ? g2[y] : g2.readUInt16BE(y * u);
    }
    let E2;
    if (e) {
      let g2 = -1;
      for (E2 = t; E2 < h2; E2++)
        if (d(i, E2) === d(r, g2 === -1 ? 0 : E2 - g2)) {
          if (g2 === -1 && (g2 = E2), E2 - g2 + 1 === s)
            return g2 * u;
        } else
          g2 !== -1 && (E2 -= E2 - g2), g2 = -1;
    } else
      for (t + s > h2 && (t = h2 - s), E2 = t; E2 >= 0; E2--) {
        let g2 = true;
        for (let y = 0; y < s; y++)
          if (d(i, E2 + y) !== d(r, y)) {
            g2 = false;
            break;
          }
        if (g2)
          return E2;
      }
    return -1;
  }
  o.prototype.includes = function(r, t, n) {
    return this.indexOf(r, t, n) !== -1;
  }, o.prototype.indexOf = function(r, t, n) {
    return K2(this, r, t, n, true);
  }, o.prototype.lastIndexOf = function(r, t, n) {
    return K2(this, r, t, n, false);
  };
  function wr(i, r, t, n) {
    t = Number(t) || 0;
    const e = i.length - t;
    n ? (n = Number(n), n > e && (n = e)) : n = e;
    const u = r.length;
    n > u / 2 && (n = u / 2);
    let h2;
    for (h2 = 0; h2 < n; ++h2) {
      const s = parseInt(r.substr(h2 * 2, 2), 16);
      if (V2(s))
        return h2;
      i[t + h2] = s;
    }
    return h2;
  }
  function yr(i, r, t, n) {
    return P2(H2(r, i.length - t), i, t, n);
  }
  function xr(i, r, t, n) {
    return P2(Cr(r), i, t, n);
  }
  function Br(i, r, t, n) {
    return P2(hr(r), i, t, n);
  }
  function Er(i, r, t, n) {
    return P2(_r(r, i.length - t), i, t, n);
  }
  o.prototype.write = function(r, t, n, e) {
    if (t === void 0)
      e = "utf8", n = this.length, t = 0;
    else if (n === void 0 && typeof t == "string")
      e = t, n = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === void 0 && (e = "utf8")) : (e = n, n = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const u = this.length - t;
    if ((n === void 0 || n > u) && (n = u), r.length > 0 && (n < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    e || (e = "utf8");
    let h2 = false;
    for (; ; )
      switch (e) {
        case "hex":
          return wr(this, r, t, n);
        case "utf8":
        case "utf-8":
          return yr(this, r, t, n);
        case "ascii":
        case "latin1":
        case "binary":
          return xr(this, r, t, n);
        case "base64":
          return Br(this, r, t, n);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Er(this, r, t, n);
        default:
          if (h2)
            throw new TypeError("Unknown encoding: " + e);
          e = ("" + e).toLowerCase(), h2 = true;
      }
  }, o.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function dr(i, r, t) {
    return r === 0 && t === i.length ? c.fromByteArray(i) : c.fromByteArray(i.slice(r, t));
  }
  function Q2(i, r, t) {
    t = Math.min(i.length, t);
    const n = [];
    let e = r;
    for (; e < t; ) {
      const u = i[e];
      let h2 = null, s = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
      if (e + s <= t) {
        let d, E2, g2, y;
        switch (s) {
          case 1:
            u < 128 && (h2 = u);
            break;
          case 2:
            d = i[e + 1], (d & 192) === 128 && (y = (u & 31) << 6 | d & 63, y > 127 && (h2 = y));
            break;
          case 3:
            d = i[e + 1], E2 = i[e + 2], (d & 192) === 128 && (E2 & 192) === 128 && (y = (u & 15) << 12 | (d & 63) << 6 | E2 & 63, y > 2047 && (y < 55296 || y > 57343) && (h2 = y));
            break;
          case 4:
            d = i[e + 1], E2 = i[e + 2], g2 = i[e + 3], (d & 192) === 128 && (E2 & 192) === 128 && (g2 & 192) === 128 && (y = (u & 15) << 18 | (d & 63) << 12 | (E2 & 63) << 6 | g2 & 63, y > 65535 && y < 1114112 && (h2 = y));
        }
      }
      h2 === null ? (h2 = 65533, s = 1) : h2 > 65535 && (h2 -= 65536, n.push(h2 >>> 10 & 1023 | 55296), h2 = 56320 | h2 & 1023), n.push(h2), e += s;
    }
    return gr(n);
  }
  const v2 = 4096;
  function gr(i) {
    const r = i.length;
    if (r <= v2)
      return String.fromCharCode.apply(String, i);
    let t = "", n = 0;
    for (; n < r; )
      t += String.fromCharCode.apply(
        String,
        i.slice(n, n += v2)
      );
    return t;
  }
  function mr(i, r, t) {
    let n = "";
    t = Math.min(i.length, t);
    for (let e = r; e < t; ++e)
      n += String.fromCharCode(i[e] & 127);
    return n;
  }
  function Ir(i, r, t) {
    let n = "";
    t = Math.min(i.length, t);
    for (let e = r; e < t; ++e)
      n += String.fromCharCode(i[e]);
    return n;
  }
  function Fr(i, r, t) {
    const n = i.length;
    (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
    let e = "";
    for (let u = r; u < t; ++u)
      e += Sr[i[u]];
    return e;
  }
  function Ar(i, r, t) {
    const n = i.slice(r, t);
    let e = "";
    for (let u = 0; u < n.length - 1; u += 2)
      e += String.fromCharCode(n[u] + n[u + 1] * 256);
    return e;
  }
  o.prototype.slice = function(r, t) {
    const n = this.length;
    r = ~~r, t = t === void 0 ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
    const e = this.subarray(r, t);
    return Object.setPrototypeOf(e, o.prototype), e;
  };
  function I2(i, r, t) {
    if (i % 1 !== 0 || i < 0)
      throw new RangeError("offset is not uint");
    if (i + r > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  o.prototype.readUintLE = o.prototype.readUIntLE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || I2(r, t, this.length);
    let e = this[r], u = 1, h2 = 0;
    for (; ++h2 < t && (u *= 256); )
      e += this[r + h2] * u;
    return e;
  }, o.prototype.readUintBE = o.prototype.readUIntBE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || I2(r, t, this.length);
    let e = this[r + --t], u = 1;
    for (; t > 0 && (u *= 256); )
      e += this[r + --t] * u;
    return e;
  }, o.prototype.readUint8 = o.prototype.readUInt8 = function(r, t) {
    return r = r >>> 0, t || I2(r, 1, this.length), this[r];
  }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(r, t) {
    return r = r >>> 0, t || I2(r, 2, this.length), this[r] | this[r + 1] << 8;
  }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(r, t) {
    return r = r >>> 0, t || I2(r, 2, this.length), this[r] << 8 | this[r + 1];
  }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(r, t) {
    return r = r >>> 0, t || I2(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
  }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(r, t) {
    return r = r >>> 0, t || I2(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
  }, o.prototype.readBigUInt64LE = L2(function(r) {
    r = r >>> 0, k2(r, "offset");
    const t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && $2(r, this.length - 8);
    const e = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, u = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + n * 2 ** 24;
    return BigInt(e) + (BigInt(u) << BigInt(32));
  }), o.prototype.readBigUInt64BE = L2(function(r) {
    r = r >>> 0, k2(r, "offset");
    const t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && $2(r, this.length - 8);
    const e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], u = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n;
    return (BigInt(e) << BigInt(32)) + BigInt(u);
  }), o.prototype.readIntLE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || I2(r, t, this.length);
    let e = this[r], u = 1, h2 = 0;
    for (; ++h2 < t && (u *= 256); )
      e += this[r + h2] * u;
    return u *= 128, e >= u && (e -= Math.pow(2, 8 * t)), e;
  }, o.prototype.readIntBE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || I2(r, t, this.length);
    let e = t, u = 1, h2 = this[r + --e];
    for (; e > 0 && (u *= 256); )
      h2 += this[r + --e] * u;
    return u *= 128, h2 >= u && (h2 -= Math.pow(2, 8 * t)), h2;
  }, o.prototype.readInt8 = function(r, t) {
    return r = r >>> 0, t || I2(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
  }, o.prototype.readInt16LE = function(r, t) {
    r = r >>> 0, t || I2(r, 2, this.length);
    const n = this[r] | this[r + 1] << 8;
    return n & 32768 ? n | 4294901760 : n;
  }, o.prototype.readInt16BE = function(r, t) {
    r = r >>> 0, t || I2(r, 2, this.length);
    const n = this[r + 1] | this[r] << 8;
    return n & 32768 ? n | 4294901760 : n;
  }, o.prototype.readInt32LE = function(r, t) {
    return r = r >>> 0, t || I2(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
  }, o.prototype.readInt32BE = function(r, t) {
    return r = r >>> 0, t || I2(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
  }, o.prototype.readBigInt64LE = L2(function(r) {
    r = r >>> 0, k2(r, "offset");
    const t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && $2(r, this.length - 8);
    const e = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (n << 24);
    return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
  }), o.prototype.readBigInt64BE = L2(function(r) {
    r = r >>> 0, k2(r, "offset");
    const t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && $2(r, this.length - 8);
    const e = (t << 24) + // Overflow
    this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
    return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n);
  }), o.prototype.readFloatLE = function(r, t) {
    return r = r >>> 0, t || I2(r, 4, this.length), a2.read(this, r, true, 23, 4);
  }, o.prototype.readFloatBE = function(r, t) {
    return r = r >>> 0, t || I2(r, 4, this.length), a2.read(this, r, false, 23, 4);
  }, o.prototype.readDoubleLE = function(r, t) {
    return r = r >>> 0, t || I2(r, 8, this.length), a2.read(this, r, true, 52, 8);
  }, o.prototype.readDoubleBE = function(r, t) {
    return r = r >>> 0, t || I2(r, 8, this.length), a2.read(this, r, false, 52, 8);
  };
  function U2(i, r, t, n, e, u) {
    if (!o.isBuffer(i))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r > e || r < u)
      throw new RangeError('"value" argument is out of bounds');
    if (t + n > i.length)
      throw new RangeError("Index out of range");
  }
  o.prototype.writeUintLE = o.prototype.writeUIntLE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
      const s = Math.pow(2, 8 * n) - 1;
      U2(this, r, t, n, s, 0);
    }
    let u = 1, h2 = 0;
    for (this[t] = r & 255; ++h2 < n && (u *= 256); )
      this[t + h2] = r / u & 255;
    return t + n;
  }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
      const s = Math.pow(2, 8 * n) - 1;
      U2(this, r, t, n, s, 0);
    }
    let u = n - 1, h2 = 1;
    for (this[t + u] = r & 255; --u >= 0 && (h2 *= 256); )
      this[t + u] = r / h2 & 255;
    return t + n;
  }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
  }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
  }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  function rr(i, r, t, n, e) {
    ur(r, n, e, i, t, 7);
    let u = Number(r & BigInt(4294967295));
    i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u;
    let h2 = Number(r >> BigInt(32) & BigInt(4294967295));
    return i[t++] = h2, h2 = h2 >> 8, i[t++] = h2, h2 = h2 >> 8, i[t++] = h2, h2 = h2 >> 8, i[t++] = h2, t;
  }
  function tr(i, r, t, n, e) {
    ur(r, n, e, i, t, 7);
    let u = Number(r & BigInt(4294967295));
    i[t + 7] = u, u = u >> 8, i[t + 6] = u, u = u >> 8, i[t + 5] = u, u = u >> 8, i[t + 4] = u;
    let h2 = Number(r >> BigInt(32) & BigInt(4294967295));
    return i[t + 3] = h2, h2 = h2 >> 8, i[t + 2] = h2, h2 = h2 >> 8, i[t + 1] = h2, h2 = h2 >> 8, i[t] = h2, t + 8;
  }
  o.prototype.writeBigUInt64LE = L2(function(r, t = 0) {
    return rr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeBigUInt64BE = L2(function(r, t = 0) {
    return tr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeIntLE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, !e) {
      const d = Math.pow(2, 8 * n - 1);
      U2(this, r, t, n, d - 1, -d);
    }
    let u = 0, h2 = 1, s = 0;
    for (this[t] = r & 255; ++u < n && (h2 *= 256); )
      r < 0 && s === 0 && this[t + u - 1] !== 0 && (s = 1), this[t + u] = (r / h2 >> 0) - s & 255;
    return t + n;
  }, o.prototype.writeIntBE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, !e) {
      const d = Math.pow(2, 8 * n - 1);
      U2(this, r, t, n, d - 1, -d);
    }
    let u = n - 1, h2 = 1, s = 0;
    for (this[t + u] = r & 255; --u >= 0 && (h2 *= 256); )
      r < 0 && s === 0 && this[t + u + 1] !== 0 && (s = 1), this[t + u] = (r / h2 >> 0) - s & 255;
    return t + n;
  }, o.prototype.writeInt8 = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
  }, o.prototype.writeInt16LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  }, o.prototype.writeInt16BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  }, o.prototype.writeInt32LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
  }, o.prototype.writeInt32BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U2(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  }, o.prototype.writeBigInt64LE = L2(function(r, t = 0) {
    return rr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), o.prototype.writeBigInt64BE = L2(function(r, t = 0) {
    return tr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ir(i, r, t, n, e, u) {
    if (t + n > i.length)
      throw new RangeError("Index out of range");
    if (t < 0)
      throw new RangeError("Index out of range");
  }
  function nr(i, r, t, n, e) {
    return r = +r, t = t >>> 0, e || ir(i, r, t, 4), a2.write(i, r, t, n, 23, 4), t + 4;
  }
  o.prototype.writeFloatLE = function(r, t, n) {
    return nr(this, r, t, true, n);
  }, o.prototype.writeFloatBE = function(r, t, n) {
    return nr(this, r, t, false, n);
  };
  function er(i, r, t, n, e) {
    return r = +r, t = t >>> 0, e || ir(i, r, t, 8), a2.write(i, r, t, n, 52, 8), t + 8;
  }
  o.prototype.writeDoubleLE = function(r, t, n) {
    return er(this, r, t, true, n);
  }, o.prototype.writeDoubleBE = function(r, t, n) {
    return er(this, r, t, false, n);
  }, o.prototype.copy = function(r, t, n, e) {
    if (!o.isBuffer(r))
      throw new TypeError("argument should be a Buffer");
    if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (n < 0 || n >= this.length)
      throw new RangeError("Index out of range");
    if (e < 0)
      throw new RangeError("sourceEnd out of bounds");
    e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
    const u = e - n;
    return this === r && typeof f.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : f.prototype.set.call(
      r,
      this.subarray(n, e),
      t
    ), u;
  }, o.prototype.fill = function(r, t, n, e) {
    if (typeof r == "string") {
      if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== void 0 && typeof e != "string")
        throw new TypeError("encoding must be a string");
      if (typeof e == "string" && !o.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      if (r.length === 1) {
        const h2 = r.charCodeAt(0);
        (e === "utf8" && h2 < 128 || e === "latin1") && (r = h2);
      }
    } else
      typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
    if (t < 0 || this.length < t || this.length < n)
      throw new RangeError("Out of range index");
    if (n <= t)
      return this;
    t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, r || (r = 0);
    let u;
    if (typeof r == "number")
      for (u = t; u < n; ++u)
        this[u] = r;
    else {
      const h2 = o.isBuffer(r) ? r : o.from(r, e), s = h2.length;
      if (s === 0)
        throw new TypeError('The value "' + r + '" is invalid for argument "value"');
      for (u = 0; u < n - t; ++u)
        this[u + t] = h2[u % s];
    }
    return this;
  };
  const b = {};
  function q2(i, r, t) {
    b[i] = class extends t {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: r.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
      }
      get code() {
        return i;
      }
      set code(e) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: e,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${i}]: ${this.message}`;
      }
    };
  }
  q2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(i) {
      return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), q2(
    "ERR_INVALID_ARG_TYPE",
    function(i, r) {
      return `The "${i}" argument must be of type number. Received type ${typeof r}`;
    },
    TypeError
  ), q2(
    "ERR_OUT_OF_RANGE",
    function(i, r, t) {
      let n = `The value of "${i}" is out of range.`, e = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = or(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = or(e)), e += "n"), n += ` It must be ${r}. Received ${e}`, n;
    },
    RangeError
  );
  function or(i) {
    let r = "", t = i.length;
    const n = i[0] === "-" ? 1 : 0;
    for (; t >= n + 4; t -= 3)
      r = `_${i.slice(t - 3, t)}${r}`;
    return `${i.slice(0, t)}${r}`;
  }
  function Ur(i, r, t) {
    k2(r, "offset"), (i[r] === void 0 || i[r + t] === void 0) && $2(r, i.length - (t + 1));
  }
  function ur(i, r, t, n, e, u) {
    if (i > t || i < r) {
      const h2 = typeof r == "bigint" ? "n" : "";
      let s;
      throw u > 3 ? r === 0 || r === BigInt(0) ? s = `>= 0${h2} and < 2${h2} ** ${(u + 1) * 8}${h2}` : s = `>= -(2${h2} ** ${(u + 1) * 8 - 1}${h2}) and < 2 ** ${(u + 1) * 8 - 1}${h2}` : s = `>= ${r}${h2} and <= ${t}${h2}`, new b.ERR_OUT_OF_RANGE("value", s, i);
    }
    Ur(n, e, u);
  }
  function k2(i, r) {
    if (typeof i != "number")
      throw new b.ERR_INVALID_ARG_TYPE(r, "number", i);
  }
  function $2(i, r, t) {
    throw Math.floor(i) !== i ? (k2(i, t), new b.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new b.ERR_BUFFER_OUT_OF_BOUNDS() : new b.ERR_OUT_OF_RANGE(
      t || "offset",
      `>= ${t ? 1 : 0} and <= ${r}`,
      i
    );
  }
  const Rr = /[^+/0-9A-Za-z-_]/g;
  function Tr(i) {
    if (i = i.split("=")[0], i = i.trim().replace(Rr, ""), i.length < 2)
      return "";
    for (; i.length % 4 !== 0; )
      i = i + "=";
    return i;
  }
  function H2(i, r) {
    r = r || 1 / 0;
    let t;
    const n = i.length;
    let e = null;
    const u = [];
    for (let h2 = 0; h2 < n; ++h2) {
      if (t = i.charCodeAt(h2), t > 55295 && t < 57344) {
        if (!e) {
          if (t > 56319) {
            (r -= 3) > -1 && u.push(239, 191, 189);
            continue;
          } else if (h2 + 1 === n) {
            (r -= 3) > -1 && u.push(239, 191, 189);
            continue;
          }
          e = t;
          continue;
        }
        if (t < 56320) {
          (r -= 3) > -1 && u.push(239, 191, 189), e = t;
          continue;
        }
        t = (e - 55296 << 10 | t - 56320) + 65536;
      } else
        e && (r -= 3) > -1 && u.push(239, 191, 189);
      if (e = null, t < 128) {
        if ((r -= 1) < 0)
          break;
        u.push(t);
      } else if (t < 2048) {
        if ((r -= 2) < 0)
          break;
        u.push(
          t >> 6 | 192,
          t & 63 | 128
        );
      } else if (t < 65536) {
        if ((r -= 3) < 0)
          break;
        u.push(
          t >> 12 | 224,
          t >> 6 & 63 | 128,
          t & 63 | 128
        );
      } else if (t < 1114112) {
        if ((r -= 4) < 0)
          break;
        u.push(
          t >> 18 | 240,
          t >> 12 & 63 | 128,
          t >> 6 & 63 | 128,
          t & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return u;
  }
  function Cr(i) {
    const r = [];
    for (let t = 0; t < i.length; ++t)
      r.push(i.charCodeAt(t) & 255);
    return r;
  }
  function _r(i, r) {
    let t, n, e;
    const u = [];
    for (let h2 = 0; h2 < i.length && !((r -= 2) < 0); ++h2)
      t = i.charCodeAt(h2), n = t >> 8, e = t % 256, u.push(e), u.push(n);
    return u;
  }
  function hr(i) {
    return c.toByteArray(Tr(i));
  }
  function P2(i, r, t, n) {
    let e;
    for (e = 0; e < n && !(e + t >= r.length || e >= i.length); ++e)
      r[e + t] = i[e];
    return e;
  }
  function C(i, r) {
    return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
  }
  function V2(i) {
    return i !== i;
  }
  const Sr = function() {
    const i = "0123456789abcdef", r = new Array(256);
    for (let t = 0; t < 16; ++t) {
      const n = t * 16;
      for (let e = 0; e < 16; ++e)
        r[n + e] = i[t] + i[e];
    }
    return r;
  }();
  function L2(i) {
    return typeof BigInt > "u" ? Lr : i;
  }
  function Lr() {
    throw new Error("BigInt not supported");
  }
})(fr);
var Yr = fr.Buffer;

// node_modules/@realpage/rum-react-library/dist/axios/index.js
function Ce(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
var { toString: et } = Object.prototype;
var { getPrototypeOf: ie } = Object;
var J2 = /* @__PURE__ */ ((e) => (t) => {
  const r = et.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var A = (e) => (e = e.toLowerCase(), (t) => J2(t) === e);
var $ = (e) => (t) => typeof t === e;
var { isArray: _2 } = Array;
var U = $("undefined");
function tt(e) {
  return e !== null && !U(e) && e.constructor !== null && !U(e.constructor) && g(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
var Pe = A("ArrayBuffer");
function nt(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && Pe(e.buffer), t;
}
var rt = $("string");
var g = $("function");
var Ne = $("number");
var V = (e) => e !== null && typeof e == "object";
var st = (e) => e === true || e === false;
var j = (e) => {
  if (J2(e) !== "object")
    return false;
  const t = ie(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
};
var ot = A("Date");
var it = A("File");
var at = A("Blob");
var ct = A("FileList");
var ut = (e) => V(e) && g(e.pipe);
var lt = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || g(e.append) && ((t = J2(e)) === "formdata" || // detect form-data instance
  t === "object" && g(e.toString) && e.toString() === "[object FormData]"));
};
var ft = A("URLSearchParams");
var [dt, pt, ht, mt] = ["ReadableStream", "Request", "Response", "Headers"].map(A);
var yt = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function k(e, t, { allOwnKeys: r = false } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, s;
  if (typeof e != "object" && (e = [e]), _2(e))
    for (n = 0, s = e.length; n < s; n++)
      t.call(null, e[n], n, e);
  else {
    const o = r ? Object.getOwnPropertyNames(e) : Object.keys(e), i = o.length;
    let c;
    for (n = 0; n < i; n++)
      c = o[n], t.call(null, e[c], c, e);
  }
}
function Fe(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, s;
  for (; n-- > 0; )
    if (s = r[n], t === s.toLowerCase())
      return s;
  return null;
}
var _e = /* @__PURE__ */ (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : l)();
var Le = (e) => !U(e) && e !== _e;
function Y() {
  const { caseless: e } = Le(this) && this || {}, t = {}, r = (n, s) => {
    const o = e && Fe(t, s) || s;
    j(t[o]) && j(n) ? t[o] = Y(t[o], n) : j(n) ? t[o] = Y({}, n) : _2(n) ? t[o] = n.slice() : t[o] = n;
  };
  for (let n = 0, s = arguments.length; n < s; n++)
    arguments[n] && k(arguments[n], r);
  return t;
}
var wt = (e, t, r, { allOwnKeys: n } = {}) => (k(t, (s, o) => {
  r && g(s) ? e[o] = Ce(s, r) : e[o] = s;
}, { allOwnKeys: n }), e);
var bt = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e);
var Et = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
};
var Rt = (e, t, r, n) => {
  let s, o, i;
  const c = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (s = Object.getOwnPropertyNames(e), o = s.length; o-- > 0; )
      i = s[o], (!n || n(i, e, t)) && !c[i] && (t[i] = e[i], c[i] = true);
    e = r !== false && ie(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
};
var St = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
};
var gt = (e) => {
  if (!e)
    return null;
  if (_2(e))
    return e;
  let t = e.length;
  if (!Ne(t))
    return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
};
var Ot = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && ie(Uint8Array));
var Tt = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const o = s.value;
    t.call(e, o[0], o[1]);
  }
};
var At = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
};
var xt = A("HTMLFormElement");
var Ct = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, s) {
    return n.toUpperCase() + s;
  }
);
var he = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype);
var Pt = A("RegExp");
var Be = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  k(r, (s, o) => {
    let i;
    (i = t(s, o, e)) !== false && (n[o] = i || s);
  }), Object.defineProperties(e, n);
};
var Nt = (e) => {
  Be(e, (t, r) => {
    if (g(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return false;
    const n = e[r];
    if (g(n)) {
      if (t.enumerable = false, "writable" in t) {
        t.writable = false;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
};
var Ft = (e, t) => {
  const r = {}, n = (s) => {
    s.forEach((o) => {
      r[o] = true;
    });
  };
  return _2(e) ? n(e) : n(String(e).split(t)), r;
};
var _t = () => {
};
var Lt = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
var G = "abcdefghijklmnopqrstuvwxyz";
var me = "0123456789";
var De = {
  DIGIT: me,
  ALPHA: G,
  ALPHA_DIGIT: G + G.toUpperCase() + me
};
var Bt = (e = 16, t = De.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t;
  for (; e--; )
    r += t[Math.random() * n | 0];
  return r;
};
function Dt(e) {
  return !!(e && g(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
var Ut = (e) => {
  const t = new Array(10), r = (n, s) => {
    if (V(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[s] = n;
        const o = _2(n) ? [] : {};
        return k(n, (i, c) => {
          const f = r(i, s + 1);
          !U(f) && (o[c] = f);
        }), t[s] = void 0, o;
      }
    }
    return n;
  };
  return r(e, 0);
};
var kt = A("AsyncFunction");
var jt = (e) => e && (V(e) || g(e)) && g(e.then) && g(e.catch);
var a = {
  isArray: _2,
  isArrayBuffer: Pe,
  isBuffer: tt,
  isFormData: lt,
  isArrayBufferView: nt,
  isString: rt,
  isNumber: Ne,
  isBoolean: st,
  isObject: V,
  isPlainObject: j,
  isReadableStream: dt,
  isRequest: pt,
  isResponse: ht,
  isHeaders: mt,
  isUndefined: U,
  isDate: ot,
  isFile: it,
  isBlob: at,
  isRegExp: Pt,
  isFunction: g,
  isStream: ut,
  isURLSearchParams: ft,
  isTypedArray: Ot,
  isFileList: ct,
  forEach: k,
  merge: Y,
  extend: wt,
  trim: yt,
  stripBOM: bt,
  inherits: Et,
  toFlatObject: Rt,
  kindOf: J2,
  kindOfTest: A,
  endsWith: St,
  toArray: gt,
  forEachEntry: Tt,
  matchAll: At,
  isHTMLForm: xt,
  hasOwnProperty: he,
  hasOwnProp: he,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Be,
  freezeMethods: Nt,
  toObjectSet: Ft,
  toCamelCase: Ct,
  noop: _t,
  toFiniteNumber: Lt,
  findKey: Fe,
  global: _e,
  isContextDefined: Le,
  ALPHABET: De,
  generateString: Bt,
  isSpecCompliantForm: Dt,
  toJSONObject: Ut,
  isAsyncFn: kt,
  isThenable: jt
};
function h(e, t, r, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), s && (this.response = s);
}
a.inherits(h, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: a.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var Ue = h.prototype;
var ke = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  ke[e] = { value: e };
});
Object.defineProperties(h, ke);
Object.defineProperty(Ue, "isAxiosError", { value: true });
h.from = (e, t, r, n, s, o) => {
  const i = Object.create(Ue);
  return a.toFlatObject(e, i, function(f) {
    return f !== Error.prototype;
  }, (c) => c !== "isAxiosError"), h.call(i, e.message, t, r, n, s), i.cause = e, i.name = e.name, o && Object.assign(i, o), i;
};
var qt = null;
function ee(e) {
  return a.isPlainObject(e) || a.isArray(e);
}
function je(e) {
  return a.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function ye(e, t, r) {
  return e ? e.concat(t).map(function(s, o) {
    return s = je(s), !r && o ? "[" + s + "]" : s;
  }).join(r ? "." : "") : t;
}
function Ht(e) {
  return a.isArray(e) && !e.some(ee);
}
var It = a.toFlatObject(a, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function W(e, t, r) {
  if (!a.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = a.toFlatObject(r, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function(m, R) {
    return !a.isUndefined(R[m]);
  });
  const n = r.metaTokens, s = r.visitor || u, o = r.dots, i = r.indexes, f = (r.Blob || typeof Blob < "u" && Blob) && a.isSpecCompliantForm(t);
  if (!a.isFunction(s))
    throw new TypeError("visitor must be a function");
  function l2(d) {
    if (d === null)
      return "";
    if (a.isDate(d))
      return d.toISOString();
    if (!f && a.isBlob(d))
      throw new h("Blob is not supported. Use a Buffer instead.");
    return a.isArrayBuffer(d) || a.isTypedArray(d) ? f && typeof Blob == "function" ? new Blob([d]) : Yr.from(d) : d;
  }
  function u(d, m, R) {
    let S = d;
    if (d && !R && typeof d == "object") {
      if (a.endsWith(m, "{}"))
        m = n ? m : m.slice(0, -2), d = JSON.stringify(d);
      else if (a.isArray(d) && Ht(d) || (a.isFileList(d) || a.endsWith(m, "[]")) && (S = a.toArray(d)))
        return m = je(m), S.forEach(function(w, B) {
          !(a.isUndefined(w) || w === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            i === true ? ye([m], B, o) : i === null ? m : m + "[]",
            l2(w)
          );
        }), false;
    }
    return ee(d) ? true : (t.append(ye(R, m, o), l2(d)), false);
  }
  const p = [], b = Object.assign(It, {
    defaultVisitor: u,
    convertValue: l2,
    isVisitable: ee
  });
  function y(d, m) {
    if (!a.isUndefined(d)) {
      if (p.indexOf(d) !== -1)
        throw Error("Circular reference detected in " + m.join("."));
      p.push(d), a.forEach(d, function(S, x) {
        (!(a.isUndefined(S) || S === null) && s.call(
          t,
          S,
          a.isString(x) ? x.trim() : x,
          m,
          b
        )) === true && y(S, m ? m.concat(x) : [x]);
      }), p.pop();
    }
  }
  if (!a.isObject(e))
    throw new TypeError("data must be an object");
  return y(e), t;
}
function we(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function ae(e, t) {
  this._pairs = [], e && W(e, this, t);
}
var qe = ae.prototype;
qe.append = function(t, r) {
  this._pairs.push([t, r]);
};
qe.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, we);
  } : we;
  return this._pairs.map(function(s) {
    return r(s[0]) + "=" + r(s[1]);
  }, "").join("&");
};
function Mt(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function He(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || Mt, s = r && r.serialize;
  let o;
  if (s ? o = s(t, r) : o = a.isURLSearchParams(t) ? t.toString() : new ae(t, r).toString(n), o) {
    const i = e.indexOf("#");
    i !== -1 && (e = e.slice(0, i)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return e;
}
var zt = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : false,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    a.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
};
var be = zt;
var Ie = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var Jt = typeof URLSearchParams < "u" ? URLSearchParams : ae;
var $t = typeof FormData < "u" ? FormData : null;
var Vt = typeof Blob < "u" ? Blob : null;
var Wt = {
  isBrowser: true,
  classes: {
    URLSearchParams: Jt,
    FormData: $t,
    Blob: Vt
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
var ce = typeof window < "u" && typeof document < "u";
var Kt = ((e) => ce && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product);
var vt = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")();
var Gt = ce && window.location.href || "http://localhost";
var Xt = Object.freeze(Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: ce,
  hasStandardBrowserEnv: Kt,
  hasStandardBrowserWebWorkerEnv: vt,
  origin: Gt
}, Symbol.toStringTag, { value: "Module" }));
var O2 = {
  ...Xt,
  ...Wt
};
function Qt(e, t) {
  return W(e, new O2.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, s, o) {
      return O2.isNode && a.isBuffer(r) ? (this.append(n, r.toString("base64")), false) : o.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function Zt(e) {
  return a.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function Yt(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const s = r.length;
  let o;
  for (n = 0; n < s; n++)
    o = r[n], t[o] = e[o];
  return t;
}
function Me(e) {
  function t(r, n, s, o) {
    let i = r[o++];
    if (i === "__proto__")
      return true;
    const c = Number.isFinite(+i), f = o >= r.length;
    return i = !i && a.isArray(s) ? s.length : i, f ? (a.hasOwnProp(s, i) ? s[i] = [s[i], n] : s[i] = n, !c) : ((!s[i] || !a.isObject(s[i])) && (s[i] = []), t(r, n, s[i], o) && a.isArray(s[i]) && (s[i] = Yt(s[i])), !c);
  }
  if (a.isFormData(e) && a.isFunction(e.entries)) {
    const r = {};
    return a.forEachEntry(e, (n, s) => {
      t(Zt(n), s, r, 0);
    }), r;
  }
  return null;
}
function en(e, t, r) {
  if (a.isString(e))
    try {
      return (t || JSON.parse)(e), a.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(e);
}
var ue = {
  transitional: Ie,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", s = n.indexOf("application/json") > -1, o = a.isObject(t);
    if (o && a.isHTMLForm(t) && (t = new FormData(t)), a.isFormData(t))
      return s ? JSON.stringify(Me(t)) : t;
    if (a.isArrayBuffer(t) || a.isBuffer(t) || a.isStream(t) || a.isFile(t) || a.isBlob(t) || a.isReadableStream(t))
      return t;
    if (a.isArrayBufferView(t))
      return t.buffer;
    if (a.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), t.toString();
    let c;
    if (o) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return Qt(t, this.formSerializer).toString();
      if ((c = a.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const f = this.env && this.env.FormData;
        return W(
          c ? { "files[]": t } : t,
          f && new f(),
          this.formSerializer
        );
      }
    }
    return o || s ? (r.setContentType("application/json", false), en(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || ue.transitional, n = r && r.forcedJSONParsing, s = this.responseType === "json";
    if (a.isResponse(t) || a.isReadableStream(t))
      return t;
    if (t && a.isString(t) && (n && !this.responseType || s)) {
      const i = !(r && r.silentJSONParsing) && s;
      try {
        return JSON.parse(t);
      } catch (c) {
        if (i)
          throw c.name === "SyntaxError" ? h.from(c, h.ERR_BAD_RESPONSE, this, null, this.response) : c;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: O2.classes.FormData,
    Blob: O2.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
a.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  ue.headers[e] = {};
});
var le = ue;
var tn = a.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var nn = (e) => {
  const t = {};
  let r, n, s;
  return e && e.split(`
`).forEach(function(i) {
    s = i.indexOf(":"), r = i.substring(0, s).trim().toLowerCase(), n = i.substring(s + 1).trim(), !(!r || t[r] && tn[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
};
var Ee = Symbol("internals");
function D(e) {
  return e && String(e).trim().toLowerCase();
}
function q(e) {
  return e === false || e == null ? e : a.isArray(e) ? e.map(q) : String(e);
}
function rn(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
var sn = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function X2(e, t, r, n, s) {
  if (a.isFunction(n))
    return n.call(this, t, r);
  if (s && (t = r), !!a.isString(t)) {
    if (a.isString(n))
      return t.indexOf(n) !== -1;
    if (a.isRegExp(n))
      return n.test(t);
  }
}
function on(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function an(e, t) {
  const r = a.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(s, o, i) {
        return this[n].call(this, t, s, o, i);
      },
      configurable: true
    });
  });
}
var K = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const s = this;
    function o(c, f, l2) {
      const u = D(f);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const p = a.findKey(s, u);
      (!p || s[p] === void 0 || l2 === true || l2 === void 0 && s[p] !== false) && (s[p || f] = q(c));
    }
    const i = (c, f) => a.forEach(c, (l2, u) => o(l2, u, f));
    if (a.isPlainObject(t) || t instanceof this.constructor)
      i(t, r);
    else if (a.isString(t) && (t = t.trim()) && !sn(t))
      i(nn(t), r);
    else if (a.isHeaders(t))
      for (const [c, f] of t.entries())
        o(f, c, n);
    else
      t != null && o(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = D(t), t) {
      const n = a.findKey(this, t);
      if (n) {
        const s = this[n];
        if (!r)
          return s;
        if (r === true)
          return rn(s);
        if (a.isFunction(r))
          return r.call(this, s, n);
        if (a.isRegExp(r))
          return r.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = D(t), t) {
      const n = a.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || X2(this, this[n], n, r)));
    }
    return false;
  }
  delete(t, r) {
    const n = this;
    let s = false;
    function o(i) {
      if (i = D(i), i) {
        const c = a.findKey(n, i);
        c && (!r || X2(n, n[c], c, r)) && (delete n[c], s = true);
      }
    }
    return a.isArray(t) ? t.forEach(o) : o(t), s;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, s = false;
    for (; n--; ) {
      const o = r[n];
      (!t || X2(this, this[o], o, t, true)) && (delete this[o], s = true);
    }
    return s;
  }
  normalize(t) {
    const r = this, n = {};
    return a.forEach(this, (s, o) => {
      const i = a.findKey(n, o);
      if (i) {
        r[i] = q(s), delete r[o];
        return;
      }
      const c = t ? on(o) : String(o).trim();
      c !== o && delete r[o], r[c] = q(s), n[c] = true;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return a.forEach(this, (n, s) => {
      n != null && n !== false && (r[s] = t && a.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((s) => n.set(s)), n;
  }
  static accessor(t) {
    const n = (this[Ee] = this[Ee] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function o(i) {
      const c = D(i);
      n[c] || (an(s, i), n[c] = true);
    }
    return a.isArray(t) ? t.forEach(o) : o(t), this;
  }
};
K.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
a.reduceDescriptors(K.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
a.freezeMethods(K);
var T2 = K;
function Q(e, t) {
  const r = this || le, n = t || r, s = T2.from(n.headers);
  let o = n.data;
  return a.forEach(e, function(c) {
    o = c.call(r, o, s.normalize(), t ? t.status : void 0);
  }), s.normalize(), o;
}
function ze(e) {
  return !!(e && e.__CANCEL__);
}
function L(e, t, r) {
  h.call(this, e ?? "canceled", h.ERR_CANCELED, t, r), this.name = "CanceledError";
}
a.inherits(L, h, {
  __CANCEL__: true
});
function Je(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new h(
    "Request failed with status code " + r.status,
    [h.ERR_BAD_REQUEST, h.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function cn(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function un(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let s = 0, o = 0, i;
  return t = t !== void 0 ? t : 1e3, function(f) {
    const l2 = Date.now(), u = n[o];
    i || (i = l2), r[s] = f, n[s] = l2;
    let p = o, b = 0;
    for (; p !== s; )
      b += r[p++], p = p % e;
    if (s = (s + 1) % e, s === o && (o = (o + 1) % e), l2 - i < t)
      return;
    const y = u && l2 - u;
    return y ? Math.round(b * 1e3 / y) : void 0;
  };
}
function ln(e, t) {
  let r = 0;
  const n = 1e3 / t;
  let s = null;
  return function() {
    const i = this === true, c = Date.now();
    if (i || c - r > n)
      return s && (clearTimeout(s), s = null), r = c, e.apply(null, arguments);
    s || (s = setTimeout(() => (s = null, r = Date.now(), e.apply(null, arguments)), n - (c - r)));
  };
}
var I = (e, t, r = 3) => {
  let n = 0;
  const s = un(50, 250);
  return ln((o) => {
    const i = o.loaded, c = o.lengthComputable ? o.total : void 0, f = i - n, l2 = s(f), u = i <= c;
    n = i;
    const p = {
      loaded: i,
      total: c,
      progress: c ? i / c : void 0,
      bytes: f,
      rate: l2 || void 0,
      estimated: l2 && c && u ? (c - i) / l2 : void 0,
      event: o,
      lengthComputable: c != null
    };
    p[t ? "download" : "upload"] = true, e(p);
  }, r);
};
var fn = O2.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");
    let n;
    function s(o) {
      let i = o;
      return t && (r.setAttribute("href", i), i = r.href), r.setAttribute("href", i), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return n = s(window.location.href), function(i) {
      const c = a.isString(i) ? s(i) : i;
      return c.protocol === n.protocol && c.host === n.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return true;
    };
  }()
);
var dn = O2.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, s, o) {
      const i = [e + "=" + encodeURIComponent(t)];
      a.isNumber(r) && i.push("expires=" + new Date(r).toGMTString()), a.isString(n) && i.push("path=" + n), a.isString(s) && i.push("domain=" + s), o === true && i.push("secure"), document.cookie = i.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function pn(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function hn(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function $e(e, t) {
  return e && !pn(t) ? hn(e, t) : t;
}
var Re = (e) => e instanceof T2 ? { ...e } : e;
function N(e, t) {
  t = t || {};
  const r = {};
  function n(l2, u, p) {
    return a.isPlainObject(l2) && a.isPlainObject(u) ? a.merge.call({ caseless: p }, l2, u) : a.isPlainObject(u) ? a.merge({}, u) : a.isArray(u) ? u.slice() : u;
  }
  function s(l2, u, p) {
    if (a.isUndefined(u)) {
      if (!a.isUndefined(l2))
        return n(void 0, l2, p);
    } else
      return n(l2, u, p);
  }
  function o(l2, u) {
    if (!a.isUndefined(u))
      return n(void 0, u);
  }
  function i(l2, u) {
    if (a.isUndefined(u)) {
      if (!a.isUndefined(l2))
        return n(void 0, l2);
    } else
      return n(void 0, u);
  }
  function c(l2, u, p) {
    if (p in t)
      return n(l2, u);
    if (p in e)
      return n(void 0, l2);
  }
  const f = {
    url: o,
    method: o,
    data: o,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    withXSRFToken: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: c,
    headers: (l2, u) => s(Re(l2), Re(u), true)
  };
  return a.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const p = f[u] || s, b = p(e[u], t[u], u);
    a.isUndefined(b) && p !== c || (r[u] = b);
  }), r;
}
var Ve = (e) => {
  const t = N({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: s, xsrfCookieName: o, headers: i, auth: c } = t;
  t.headers = i = T2.from(i), t.url = He($e(t.baseURL, t.url), e.params, e.paramsSerializer), c && i.set(
    "Authorization",
    "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))
  );
  let f;
  if (a.isFormData(r)) {
    if (O2.hasStandardBrowserEnv || O2.hasStandardBrowserWebWorkerEnv)
      i.setContentType(void 0);
    else if ((f = i.getContentType()) !== false) {
      const [l2, ...u] = f ? f.split(";").map((p) => p.trim()).filter(Boolean) : [];
      i.setContentType([l2 || "multipart/form-data", ...u].join("; "));
    }
  }
  if (O2.hasStandardBrowserEnv && (n && a.isFunction(n) && (n = n(t)), n || n !== false && fn(t.url))) {
    const l2 = s && o && dn.read(o);
    l2 && i.set(s, l2);
  }
  return t;
};
var mn = typeof XMLHttpRequest < "u";
var yn = mn && function(e) {
  return new Promise(function(r, n) {
    const s = Ve(e);
    let o = s.data;
    const i = T2.from(s.headers).normalize();
    let { responseType: c } = s, f;
    function l2() {
      s.cancelToken && s.cancelToken.unsubscribe(f), s.signal && s.signal.removeEventListener("abort", f);
    }
    let u = new XMLHttpRequest();
    u.open(s.method.toUpperCase(), s.url, true), u.timeout = s.timeout;
    function p() {
      if (!u)
        return;
      const y = T2.from(
        "getAllResponseHeaders" in u && u.getAllResponseHeaders()
      ), m = {
        data: !c || c === "text" || c === "json" ? u.responseText : u.response,
        status: u.status,
        statusText: u.statusText,
        headers: y,
        config: e,
        request: u
      };
      Je(function(S) {
        r(S), l2();
      }, function(S) {
        n(S), l2();
      }, m), u = null;
    }
    "onloadend" in u ? u.onloadend = p : u.onreadystatechange = function() {
      !u || u.readyState !== 4 || u.status === 0 && !(u.responseURL && u.responseURL.indexOf("file:") === 0) || setTimeout(p);
    }, u.onabort = function() {
      u && (n(new h("Request aborted", h.ECONNABORTED, s, u)), u = null);
    }, u.onerror = function() {
      n(new h("Network Error", h.ERR_NETWORK, s, u)), u = null;
    }, u.ontimeout = function() {
      let d = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const m = s.transitional || Ie;
      s.timeoutErrorMessage && (d = s.timeoutErrorMessage), n(new h(
        d,
        m.clarifyTimeoutError ? h.ETIMEDOUT : h.ECONNABORTED,
        s,
        u
      )), u = null;
    }, o === void 0 && i.setContentType(null), "setRequestHeader" in u && a.forEach(i.toJSON(), function(d, m) {
      u.setRequestHeader(m, d);
    }), a.isUndefined(s.withCredentials) || (u.withCredentials = !!s.withCredentials), c && c !== "json" && (u.responseType = s.responseType), typeof s.onDownloadProgress == "function" && u.addEventListener("progress", I(s.onDownloadProgress, true)), typeof s.onUploadProgress == "function" && u.upload && u.upload.addEventListener("progress", I(s.onUploadProgress)), (s.cancelToken || s.signal) && (f = (y) => {
      u && (n(!y || y.type ? new L(null, e, u) : y), u.abort(), u = null);
    }, s.cancelToken && s.cancelToken.subscribe(f), s.signal && (s.signal.aborted ? f() : s.signal.addEventListener("abort", f)));
    const b = cn(s.url);
    if (b && O2.protocols.indexOf(b) === -1) {
      n(new h("Unsupported protocol " + b + ":", h.ERR_BAD_REQUEST, e));
      return;
    }
    u.send(o || null);
  });
};
var wn = (e, t) => {
  let r = new AbortController(), n;
  const s = function(f) {
    if (!n) {
      n = true, i();
      const l2 = f instanceof Error ? f : this.reason;
      r.abort(l2 instanceof h ? l2 : new L(l2 instanceof Error ? l2.message : l2));
    }
  };
  let o = t && setTimeout(() => {
    s(new h(`timeout ${t} of ms exceeded`, h.ETIMEDOUT));
  }, t);
  const i = () => {
    e && (o && clearTimeout(o), o = null, e.forEach((f) => {
      f && (f.removeEventListener ? f.removeEventListener("abort", s) : f.unsubscribe(s));
    }), e = null);
  };
  e.forEach((f) => f && f.addEventListener && f.addEventListener("abort", s));
  const { signal: c } = r;
  return c.unsubscribe = i, [c, () => {
    o && clearTimeout(o), o = null;
  }];
};
var bn = wn;
var En = function* (e, t) {
  let r = e.byteLength;
  if (!t || r < t) {
    yield e;
    return;
  }
  let n = 0, s;
  for (; n < r; )
    s = n + t, yield e.slice(n, s), n = s;
};
var Rn = async function* (e, t, r) {
  for await (const n of e)
    yield* En(ArrayBuffer.isView(n) ? n : await r(String(n)), t);
};
var Se = (e, t, r, n, s) => {
  const o = Rn(e, t, s);
  let i = 0;
  return new ReadableStream({
    type: "bytes",
    async pull(c) {
      const { done: f, value: l2 } = await o.next();
      if (f) {
        c.close(), n();
        return;
      }
      let u = l2.byteLength;
      r && r(i += u), c.enqueue(new Uint8Array(l2));
    },
    cancel(c) {
      return n(c), o.return();
    }
  }, {
    highWaterMark: 2
  });
};
var ge = (e, t) => {
  const r = e != null;
  return (n) => setTimeout(() => t({
    lengthComputable: r,
    total: e,
    loaded: n
  }));
};
var v = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function";
var We = v && typeof ReadableStream == "function";
var te = v && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer()));
var Sn = We && (() => {
  let e = false;
  const t = new Request(O2.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = true, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
})();
var Oe = 64 * 1024;
var ne = We && !!(() => {
  try {
    return a.isReadableStream(new Response("").body);
  } catch {
  }
})();
var M = {
  stream: ne && ((e) => e.body)
};
v && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !M[t] && (M[t] = a.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new h(`Response type '${t}' is not supported`, h.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
var gn = async (e) => {
  if (e == null)
    return 0;
  if (a.isBlob(e))
    return e.size;
  if (a.isSpecCompliantForm(e))
    return (await new Request(e).arrayBuffer()).byteLength;
  if (a.isArrayBufferView(e))
    return e.byteLength;
  if (a.isURLSearchParams(e) && (e = e + ""), a.isString(e))
    return (await te(e)).byteLength;
};
var On = async (e, t) => {
  const r = a.toFiniteNumber(e.getContentLength());
  return r ?? gn(t);
};
var Tn = v && (async (e) => {
  let {
    url: t,
    method: r,
    data: n,
    signal: s,
    cancelToken: o,
    timeout: i,
    onDownloadProgress: c,
    onUploadProgress: f,
    responseType: l2,
    headers: u,
    withCredentials: p = "same-origin",
    fetchOptions: b
  } = Ve(e);
  l2 = l2 ? (l2 + "").toLowerCase() : "text";
  let [y, d] = s || o || i ? bn([s, o], i) : [], m, R;
  const S = () => {
    !m && setTimeout(() => {
      y && y.unsubscribe();
    }), m = true;
  };
  let x;
  try {
    if (f && Sn && r !== "get" && r !== "head" && (x = await On(u, n)) !== 0) {
      let C = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
      }), F;
      a.isFormData(n) && (F = C.headers.get("content-type")) && u.setContentType(F), C.body && (n = Se(C.body, Oe, ge(
        x,
        I(f)
      ), null, te));
    }
    a.isString(p) || (p = p ? "cors" : "omit"), R = new Request(t, {
      ...b,
      signal: y,
      method: r.toUpperCase(),
      headers: u.normalize().toJSON(),
      body: n,
      duplex: "half",
      withCredentials: p
    });
    let w = await fetch(R);
    const B = ne && (l2 === "stream" || l2 === "response");
    if (ne && (c || B)) {
      const C = {};
      ["status", "statusText", "headers"].forEach((pe) => {
        C[pe] = w[pe];
      });
      const F = a.toFiniteNumber(w.headers.get("content-length"));
      w = new Response(
        Se(w.body, Oe, c && ge(
          F,
          I(c, true)
        ), B && S, te),
        C
      );
    }
    l2 = l2 || "text";
    let Qe = await M[a.findKey(M, l2) || "text"](w, e);
    return !B && S(), d && d(), await new Promise((C, F) => {
      Je(C, F, {
        data: Qe,
        headers: T2.from(w.headers),
        status: w.status,
        statusText: w.statusText,
        config: e,
        request: R
      });
    });
  } catch (w) {
    throw S(), w && w.name === "TypeError" && /fetch/i.test(w.message) ? Object.assign(
      new h("Network Error", h.ERR_NETWORK, e, R),
      {
        cause: w.cause || w
      }
    ) : h.from(w, w && w.code, e, R);
  }
});
var re = {
  http: qt,
  xhr: yn,
  fetch: Tn
};
a.forEach(re, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
var Te = (e) => `- ${e}`;
var An = (e) => a.isFunction(e) || e === null || e === false;
var Ke = {
  getAdapter: (e) => {
    e = a.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const s = {};
    for (let o = 0; o < t; o++) {
      r = e[o];
      let i;
      if (n = r, !An(r) && (n = re[(i = String(r)).toLowerCase()], n === void 0))
        throw new h(`Unknown adapter '${i}'`);
      if (n)
        break;
      s[i || "#" + o] = n;
    }
    if (!n) {
      const o = Object.entries(s).map(
        ([c, f]) => `adapter ${c} ` + (f === false ? "is not supported by the environment" : "is not available in the build")
      );
      let i = t ? o.length > 1 ? `since :
` + o.map(Te).join(`
`) : " " + Te(o[0]) : "as no adapter specified";
      throw new h(
        "There is no suitable adapter to dispatch the request " + i,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: re
};
function Z(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new L(null, e);
}
function Ae(e) {
  return Z(e), e.headers = T2.from(e.headers), e.data = Q.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", false), Ke.getAdapter(e.adapter || le.adapter)(e).then(function(n) {
    return Z(e), n.data = Q.call(
      e,
      e.transformResponse,
      n
    ), n.headers = T2.from(n.headers), n;
  }, function(n) {
    return ze(n) || (Z(e), n && n.response && (n.response.data = Q.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = T2.from(n.response.headers))), Promise.reject(n);
  });
}
var ve = "1.7.2";
var fe = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  fe[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
var xe = {};
fe.transitional = function(t, r, n) {
  function s(o, i) {
    return "[Axios v" + ve + "] Transitional option '" + o + "'" + i + (n ? ". " + n : "");
  }
  return (o, i, c) => {
    if (t === false)
      throw new h(
        s(i, " has been removed" + (r ? " in " + r : "")),
        h.ERR_DEPRECATED
      );
    return r && !xe[i] && (xe[i] = true, console.warn(
      s(
        i,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(o, i, c) : true;
  };
};
function xn(e, t, r) {
  if (typeof e != "object")
    throw new h("options must be an object", h.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let s = n.length;
  for (; s-- > 0; ) {
    const o = n[s], i = t[o];
    if (i) {
      const c = e[o], f = c === void 0 || i(c, o, e);
      if (f !== true)
        throw new h("option " + o + " must be " + f, h.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== true)
      throw new h("Unknown option " + o, h.ERR_BAD_OPTION);
  }
}
var se = {
  assertOptions: xn,
  validators: fe
};
var P = se.validators;
var z = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new be(),
      response: new be()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
        let s;
        Error.captureStackTrace ? Error.captureStackTrace(s = {}) : s = new Error();
        const o = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? o && !String(n.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + o) : n.stack = o;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = N(this.defaults, r);
    const { transitional: n, paramsSerializer: s, headers: o } = r;
    n !== void 0 && se.assertOptions(n, {
      silentJSONParsing: P.transitional(P.boolean),
      forcedJSONParsing: P.transitional(P.boolean),
      clarifyTimeoutError: P.transitional(P.boolean)
    }, false), s != null && (a.isFunction(s) ? r.paramsSerializer = {
      serialize: s
    } : se.assertOptions(s, {
      encode: P.function,
      serialize: P.function
    }, true)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let i = o && a.merge(
      o.common,
      o[r.method]
    );
    o && a.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (d) => {
        delete o[d];
      }
    ), r.headers = T2.concat(i, o);
    const c = [];
    let f = true;
    this.interceptors.request.forEach(function(m) {
      typeof m.runWhen == "function" && m.runWhen(r) === false || (f = f && m.synchronous, c.unshift(m.fulfilled, m.rejected));
    });
    const l2 = [];
    this.interceptors.response.forEach(function(m) {
      l2.push(m.fulfilled, m.rejected);
    });
    let u, p = 0, b;
    if (!f) {
      const d = [Ae.bind(this), void 0];
      for (d.unshift.apply(d, c), d.push.apply(d, l2), b = d.length, u = Promise.resolve(r); p < b; )
        u = u.then(d[p++], d[p++]);
      return u;
    }
    b = c.length;
    let y = r;
    for (p = 0; p < b; ) {
      const d = c[p++], m = c[p++];
      try {
        y = d(y);
      } catch (R) {
        m.call(this, R);
        break;
      }
    }
    try {
      u = Ae.call(this, y);
    } catch (d) {
      return Promise.reject(d);
    }
    for (p = 0, b = l2.length; p < b; )
      u = u.then(l2[p++], l2[p++]);
    return u;
  }
  getUri(t) {
    t = N(this.defaults, t);
    const r = $e(t.baseURL, t.url);
    return He(r, t.params, t.paramsSerializer);
  }
};
a.forEach(["delete", "get", "head", "options"], function(t) {
  z.prototype[t] = function(r, n) {
    return this.request(N(n || {}, {
      method: t,
      url: r,
      data: (n || {}).data
    }));
  };
});
a.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(o, i, c) {
      return this.request(N(c || {}, {
        method: t,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: i
      }));
    };
  }
  z.prototype[t] = r(), z.prototype[t + "Form"] = r(true);
});
var H = z;
var de = class _de {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners)
        return;
      let o = n._listeners.length;
      for (; o-- > 0; )
        n._listeners[o](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let o;
      const i = new Promise((c) => {
        n.subscribe(c), o = c;
      }).then(s);
      return i.cancel = function() {
        n.unsubscribe(o);
      }, i;
    }, t(function(o, i, c) {
      n.reason || (n.reason = new L(o, i, c), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new _de(function(s) {
        t = s;
      }),
      cancel: t
    };
  }
};
var Cn = de;
function Pn(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function Nn(e) {
  return a.isObject(e) && e.isAxiosError === true;
}
var oe = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(oe).forEach(([e, t]) => {
  oe[t] = e;
});
var Fn = oe;
function Ge(e) {
  const t = new H(e), r = Ce(H.prototype.request, t);
  return a.extend(r, H.prototype, t, { allOwnKeys: true }), a.extend(r, t, null, { allOwnKeys: true }), r.create = function(s) {
    return Ge(N(e, s));
  }, r;
}
var E = Ge(le);
E.Axios = H;
E.CanceledError = L;
E.CancelToken = Cn;
E.isCancel = ze;
E.VERSION = ve;
E.toFormData = W;
E.AxiosError = h;
E.Cancel = E.CanceledError;
E.all = function(t) {
  return Promise.all(t);
};
E.spread = Pn;
E.isAxiosError = Nn;
E.mergeConfig = N;
E.AxiosHeaders = T2;
E.formToJSON = (e) => Me(a.isHTMLForm(e) ? new FormData(e) : e);
E.getAdapter = Ke.getAdapter;
E.HttpStatusCode = Fn;
E.default = E;
var _n = E;
var Xe = _n.create({
  headers: {
    "Content-Type": "application/json"
  }
});
Xe.interceptors.response.use(
  (e) => e,
  (e) => Promise.reject(e)
);
var Dn = (e, t, r) => {
  Xe.interceptors.request.use(
    (n) => {
      var o;
      const s = e.token;
      return s && (n.headers.Authorization = `Bearer ${s}`, n.headers.Username = t, n.headers["Content-Id"] = r), ((o = n.params) == null ? void 0 : o.authorizationInterceptor) === false && delete n.headers.Authorization, n;
    },
    (n) => Promise.reject(n)
  );
};

export {
  l,
  Yr,
  Xe,
  Dn
};
/*! Bundled license information:

@realpage/rum-react-library/dist/index-e5d51460.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=chunk-ZQR4QII5.js.map
